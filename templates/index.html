<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visual App</title>
    <link rel="stylesheet" href="../static/css/index.css">
</head>
<body>
    <div class="header">
<<<<<<< Updated upstream
        <div class="hero">
            <h1>Sorting Algorithms</h1>
            <p>By default we will begin with a selection sort and generate a random array of 20 items to be sorted</p>
            <form method="post">
                <select name="algorithm">
                    <option value="{{type}}">{{type}}</option>
                    <option value="selection">Selection Sort</option>
                    <option value="bubble">Bubble Sort</option>
                    <option value="Bubble Sort">Quick Sort</option>
                    <option value="merge">Merge Sort</option>
                </select>
                <input type="number" name="count" value="{{count}}">
                <input type="submit" value="Start">
            </form>
        </div>
=======
        <form method="post">
            <select name="algorithm" id="">
                <option value="BSort">Bubble Sort</option>
                <option value="sSort">Selection Sort</option>
                <option value="Bubble Sort">Quick Sort</option>
                <option value="Bubble Sort">Merge Sort</option>
            </select>
            <input type="number" name="count" value={{count}}>
            <input type="submit">
        </form>
>>>>>>> Stashed changes
    </div>
    <h2>After sorting</h2>
    <div class="table" id="table"></div>
    <h2>Before sorting</h2>
    <div class="table">
        {% for i in func[0] %}
            <div class="item" style="--item-height: {{i/func[1]*100}}%">
                {{i}}
            </div>
        {% endfor %}
    </div>
    
<script>
<<<<<<< Updated upstream
=======
    var max = `{{func[1]}}`
    max=parseInt(max)
    var data = `{{func[0]}}`
    data=JSON.parse(data)

    // We might need loops to pause on iterations
    const wait = (ms) =>{ new Promise( resolve => setTimeout(resolve,ms))}
    // lets store all the algos in a dict
    const algo = {
        //Selection sort
        selectionSort: async (data) => {

            var index = 0            
            var finalMinIndex
            var finalMin
            var currMin
            var length = data.length
            var sorted = false
            
            
            for(var iter=0; iter<data.length; iter++){
                
                finalMin=undefined
                currMin=undefined
                index++
                for(var i=index; i<length-1; i++){
                    
                    if(data[index]>data[i]){
                        console.log(data[i])
                        currMin=data[i]    
                        if(finalMin==undefined){
                            finalMin=currMin
                            finalMinIndex=i
                        }else if(currMin<finalMin){
                            finalMin=currMin
                            finalMinIndex=i
                            console.log(finalMin, ' final and index ' , finalMinIndex)
                        }
>>>>>>> Stashed changes

//Let us select our table
const table = document.getElementById('table')
//Lets get our data from python
let max = `{{func[1]}}` // largest number in array
let data = `{{func[0]}}` // Full array

//Parse our data into usable forms
max=parseInt(max)
data=JSON.parse(data)


// All algorithms will stored within algo variable dict
let algo = {
    //Start of Selection sort
    selectionSort: (data)=>{
        let index=0
        let finalMinIndex
        let finalMin
        let currMin
        let length = data.length
        
        // We might need loops to pause on iterations
        //loop through each item first
        for (let iter=0; iter<length; iter++) {
            let current = data[iter]
            finalMin=undefined
            currMin=undefined
            index++
            // compare item in current iteration with all items to its right
            for(let i=index; i<length; i++){
                if(current>data[i]){
                    currMin=data[i]
                    if(finalMin==undefined || finalMin>currMin){
                        finalMin=currMin
                        finalMinIndex=i
                    }
                    // console.log(current, ' iter: ',iter, 'data: ',data[i])
                }
            }

            //We have now iterated through all items for a target
            if(finalMin!=undefined){
                // console.log( data[finalMinIndex]," : ",data[index] )
                data[finalMinIndex]=data[iter]
                data[iter]=finalMin
                // console.log(data)

                //Code below will update the table
                let html =''
                for(let iter1=0; iter1<data.length; iter1++){
                    html=html+`
                    <div class="item ${iter1==iter?'active':''} ${iter1==finalMinIndex?'touch':''}" style="--item-height: ${data[iter1]/max*100}%">
                        ${data[iter1]}
                        </div>
                        `
                }
<<<<<<< Updated upstream
                //set timeout
                setTimeout(() => {
                    table.innerHTML=html
                }, 200*iter);

=======
                //lets add a pause os we can let the user intface notice the iterations
                setTimeout(() => {
                    updateTable(data)  
                }, 2000);
>>>>>>> Stashed changes
                
                // updateTable(i,data)

            }
            
            //lets update the data on every iteration
        }
    },
        //EOF Selection Sort

        //Start of Bubble Sort
        bubbleSort: (data) => {
            var length=data.length
            var swapped=true;
            var t=0

            //Let us track the number of steps. It is also useful for recreating a timeline
            var step=0

            while(swapped==true){
                swapped=false
                for(var index=0; index<length-1; index++){
                    step++
                    // console.log(i)
                    var left=index
                    var right=index+1
                    if(data[left]>data[right]){
                        var temp=data[left]
                        data[left]=data[right]
                        data[right]=temp
                        swapped=true
                    }

                    //Code below will update the table
                    let html =''
                    for(let iter=0; iter<data.length; iter++){
                        html=html+`
                        <div class="item ${iter==left?'active':''}  ${iter==right?'touch':''}" style="--item-height: ${data[iter]/max*100}%">
                            ${data[iter]}
                        </div>
                        `
                        //set timeout
                    }
                    setTimeout(() => {
                        table.innerHTML=html
                    }, 60*step);

                }
            }
        },
<<<<<<< Updated upstream
        // EOF Bubble sort

        //Start of Merge sort
        mergeSort: ()=>{
            var length=data.length
            var lStart,lEnd,rStart,rEnd

            if(length%2){
                lStart=parseInt(length/2-length/2)
                lEnd=parseInt(length/2)
            
                rStart=parseInt((length/2) +1)
                rEnd=parseInt(length/2+length/2)

                console.log("Left; start: ", lStart, " end: ", lEnd)
                console.log("Right; start: ", rStart, " end: ", rEnd)
            }else{
                lStart=0
                lEnd=length/2

                rStart=length/2+1
                rEnd=length/2
                
                console.log("Left; start: ", lStart, " end: ", lEnd)
                console.log("Right; start: ", rStart, " end: ", rEnd)
            }

            function left(arr,start,end){
                if(arr.length==2){
                    console.log('end')
                    return(sort(arr))
                }else if(arr.length==1){
                    console.log('test')
                }else if(arr.length>2){
                    
                    left(arr,start,arr.length)
                    right()
                }
                return
            }

            function right(arr,start,end){
                if(arr.length==2){
                    console.log('end')
                    return(sort(arr))
                }

            }

            function sort(){

            }
        }
        //EOF Merge sort
        
=======
        //EOF Selection Sort

        //Bubble Sort
        bubbleSort: async (data) => {
            var index=0
            var length=data.length
            var swapped=false;

            while(swapped==true){
                for(var i=index; i<length; i++){
                    var left=i
                    var right=i+1
                    if(data[left]>data[right]){
                        let temp=data[left]
                        data[left]=data[right]
                        data[right]=temp
                        swapped=true
                    }
                }
            }

            console.log(data)
        },
>>>>>>> Stashed changes
    }
    //EOF algo

function updateTable(i,data) {
    let table = document.getElementById('table')
    let html=''
    
    for(let iter1=0; iter1<data.length; iter1++){
        html=html+`
        <div class="item" style="--item-height: ${data[iter1]/max*100}%">
            ${data[iter1]}
            </div>
            `
    }
    table.innerHTML=html
        
}

function startAlgo(type){
    if(type=='selection')
    {
        algo.selectionSort(data)
    }
    else if(type=='bubble')
    {
        algo.bubbleSort(data)
    }  
    else if(type=='merge')
    {
        algo.mergeSort(data)
    }

}

startAlgo(`{{type}}`)
    
</script>
</body>
</html>